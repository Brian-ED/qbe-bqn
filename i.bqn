_I_ â† {ğ•¨ğ•—_ğ•£_ğ•˜â¼ğ•©: ğ•¨ğ”¾ğ•© ; ğ•¨ğ•—_ğ•£_ğ•˜ğ•©: ğ•¨ğ”½ğ•© }
#_A â† {ğ”½_I_ğ”½âŠ¸âŠ¢} # Assert's inverse is theoretically 1? Or the assertion applies in both directions, I'm not sure. I'll do both directions just in case.
#ie â† "QBE-BQN: INTERNAL ERROR: "
#C â† {ğ•Š: !2 â‹„ âŠ£Â´ğ•©; ğ•Šâ¼: !ieâˆ¾"Accidentally inverted getting a code string"   } # code string
#D â† {ğ•Š: !2 â‹„ âŠ¢Â´ğ•©; ğ•Šâ¼: !ieâˆ¾"Accidentally inverted getting a data int array"} # data int array
#_M_ â† {aâ€¿b Code _ğ•£_ Data câ€¿d: 1==Â¨ğ•¨âˆ¾ğ•©? âˆ§Â´=â—‹â€¢TypeâŸœ0Â¨ğ•¨Dğ•©?âˆ§Â´=â—‹â€¢TypeâŸœ0Â¨ğ•¨Cğ•©? ğ•¨(Codeâ‹ˆData)ğ•©}
#                           â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“ This could seem redundant since if the output of GroupSyntax is required as input to Alternative, why not just have Alternative apply GroupSyntax directly? It's because sometimes you have another function returning something which is in the codomain of GroupSyntax
#âŠ¢âŒ¾(GroupSyntaxâ¼)_I_...

# TODO: Double check when done
#   Temporary vars can only be a base type

InBetween â† {
    Inv â† (âˆ¨`â‰ â†‘ğ•©âŠ¸â·)âŒ¾âŒ½âŠ¸(Â¬âŠ¸/â‹ˆËœğ•©âˆ¾Ëœâ¼/)
    Nor â† âˆ¾âŸœğ•©âŠ¸âˆ¾Â´
    errInSA â† """"âˆ¾ğ•©âˆ¾""" is not allowed in the second element of the argument"
    errBadP â† "A prefix of """âˆ¾ğ•©âˆ¾""" is not allowed in the second element of the argument"
    ps â† (â‹ˆâˆ¾Ëœâ¼âŸ¨âŸ¨âŸ©âŸ©âˆ¾â¼âŒ½Â¨âˆ˜â†‘/Ëœâ†‘â‰¡Â¨âŒ½Â¨âˆ˜âŒ½âˆ˜â†“)ğ•© # Prefix set of invalid prefixes
    Asrt1â†errInSA!Â·âˆ§Â´âˆ˜Â¬ğ•©â·1âŠ¸âŠ‘
    Asrt2â†errBadP!Â·âˆ§Â´âˆ˜â¥Špsâ‰¢âŒœâ—‹â€¢ShowÂ·â†‘1âŠ¸âŠ‘ # Ensure if the prefix appeared in the suffix of ğ•©, that the connected string doesn't form the to-be-split primitive
    Norâˆ˜(Asrt2âŠ¸âŠ¢Asrt1âŠ¸âŠ¢) _I_ Inv
}



                   Keyword â† '"'âŠ¸(âˆ¾âˆ¾âŠ£)               # TODOO assert input is a string
               Alternative â† (InBetween" | "){ğ”½}     # TODOO add assertions about what the contents need to be # TODOO extra checks are needed on strings + Assert inputs are strings
               GroupSyntax â† 1âŒ½")("âŠ¸âˆ¾                # TODOO assert input is a string
MarkNestedSyntaxAsOptional â† 2âŒ½" ][ "âŠ¸âˆ¾              # TODOO assert input is a string, and it is a "nested syntax"
                      List â† " ),"âˆ¾Ëœ"( "âˆ¾','âˆ¾â¼','âˆ¾Â¨âŠ¢ # TODOO should only accept a list of enclosed syntax. Only strings too. Empty strings shouldn't be allowed in input list I believe?
             AnyRepitition â† âˆ¾âŸœ'*'                   # TODOO checks
       OneOrMoreRepitition â† âˆ¾âŸœ'+'                   # TODOO checks
             AggregateType â† ':'âŠ¸âˆ¾                   # TODOO has to be a valid variable
                    Global â† '$'âŠ¸âˆ¾                   # represented by a pointer # TODOO has to be a valid variable
                TempInFunc â† '%'âŠ¸âˆ¾                   # TODOO has to be a valid variable and can only be a base type
                BlockLabel â† '@'âŠ¸âˆ¾                   # TODOO has to be a valid variable

{ # Test 1
    xâ†"abc"â€¿" def"
    !"abc |  def"    â‰¡x Alternative       â†©
    !"abc |  def | c"â‰¡x Alternativeâˆ˜â‹ˆâŸœ"c" â†©
    !"abc |  def"â€¿"c"â‰¡x Alternativeâ¼      â†©
    !"abc"â€¿" def"    â‰¡x â‹ˆâŸœ"c"âˆ˜Alternativeâ¼â†©
}
â€¢Exit 0
# Spacing
#  NL := '\n'+
#  Individual tokens in IL files must be separated
#  by one or more spacing characters. Both spaces
#  and tabs are recognized as spacing characters.
#  In data and type definitions, newlines may also
#  be used as spaces to prevent overly long lines.
#  When exactly one of two consecutive tokens is a
#  symbol (for example , or = or {), spacing may be
#  omitted.

# Types
baseTypes â† i32OrStrippedI64â€¿i64â€¿f32â€¿f64 â† "wlsd" # Base types # TODO Is there a word for "Only the 32 least significant bits of a 64 bit value are used". Stripped?
extendedTypes â† baseTypes âˆ¾ i8â€¿i16 â† "bh" # They are used in Aggregate Types and Data definitions

IsIdentifier â† âŠ¢ # TODOOO
#i â† "ğ•© is a number but not an integer"!ğ•©â‰¡âŒˆâŒŠğ•© â‹„ ("-"/Ëœ0>ğ•©)âˆ¾â€¢Repr|ğ•© (!0â‰¡â—‹â€¢Typeğ•©)  # TODO Verify if float literals are allowed as numbers: "Integer isn't in bounds (!(ğ•©â‰¤Â¯1+2â‹†64)âˆ§(ğ•©â‰¥-2â‹†64))"!(ğ•©â‰¤Â¯1+2â‹†64)âˆ§(ğ•©â‰¥-2â‹†64)
Const â† {0?@
    ;I      ğ•©: ğ•© # TODOOO
    ;F32    ğ•©: "s_"âˆ¾â€¢Repr ğ•©
    ;F64    ğ•©: "d_"âˆ¾â€¢Repr ğ•©
    ;Global ğ•©: !âˆ§Â´ğ•©âˆŠâ¥Š"aA"+âŒœâ†•26 â‹„ âŠ¢âŒ¾(Globalâ¼) IsIdentifier ğ•©
}

#DYNCONST :=
#    CONST
#  | 'thread' $IDENT  # Thread-local symbol
#
#VAL :=
#    DYNCONST
#  | %IDENT

